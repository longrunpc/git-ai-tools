#!/bin/bash

# AI 기반 자동 PR 생성 스크립트
# 사용법: ./scripts/ai-pr.sh

set -e

# 색상 정의
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 설정 로드
source ~/.ai-dev-tools/config.sh

# 함수: API 키 확인
check_api_key() {
    if [ -z "$OPENAI_API_KEY" ] && [ -z "$ANTHROPIC_API_KEY" ]; then
        echo -e "${RED}❌ API 키가 설정되지 않았습니다.${NC}"
        exit 1
    fi
}

# 함수: GitHub CLI 확인
check_gh_cli() {
    if ! command -v gh &> /dev/null; then
        echo -e "${RED}❌ GitHub CLI가 설치되지 않았습니다.${NC}"
        echo "설치: brew install gh"
        echo "로그인: gh auth login"
        exit 1
    fi

    if ! gh auth status &> /dev/null; then
        echo -e "${RED}❌ GitHub CLI에 로그인되지 않았습니다.${NC}"
        echo "로그인: gh auth login"
        exit 1
    fi
}

# 함수: 원격 저장소 감지 및 설정
setup_remote_repository() {
    echo -e "${BLUE}🔍 원격 저장소를 확인하고 있습니다...${NC}"
    
    # 모든 원격 저장소 목록 가져오기
    local remotes=($(git remote))
    
    if [ ${#remotes[@]} -eq 0 ]; then
        echo -e "${YELLOW}⚠️  원격 저장소가 설정되어 있지 않습니다.${NC}"
        echo -e "${BLUE}💡 GitHub 저장소를 자동으로 생성하시겠습니까?${NC}"
        
        read -p "GitHub 저장소를 생성하고 연결하시겠습니까? (y/N): " -r
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            # 현재 디렉토리명을 저장소 이름으로 사용
            local repo_name=$(basename "$(pwd)")
            
            echo -e "${BLUE}📦 GitHub에 '$repo_name' 저장소를 생성하고 있습니다...${NC}"
            
            # GitHub CLI로 저장소 생성
            if gh repo create "$repo_name" --private --source=. --remote=origin --push; then
                echo -e "${GREEN}✅ GitHub 저장소가 성공적으로 생성되고 연결되었습니다!${NC}"
                DEFAULT_REMOTE="origin"
                # 원격 저장소 목록 재갱신
                remotes=($(git remote))
            else
                echo -e "${RED}❌ GitHub 저장소 생성에 실패했습니다.${NC}"
                echo -e "${YELLOW}💡 수동으로 저장소를 생성하고 원격 저장소를 추가해주세요:${NC}"
                echo "git remote add origin <저장소-URL>"
                exit 1
            fi
        else
            echo -e "${YELLOW}💡 수동으로 GitHub에 저장소를 생성하고 원격 저장소를 추가해주세요:${NC}"
            echo "git remote add origin <저장소-URL>"
            exit 1
        fi
    else
        # 기본 원격 저장소 결정
        if [[ " ${remotes[*]} " =~ " origin " ]]; then
            DEFAULT_REMOTE="origin"
        elif [[ " ${remotes[*]} " =~ " upstream " ]]; then
            DEFAULT_REMOTE="upstream"
        else
            DEFAULT_REMOTE="${remotes[0]}"
        fi
    fi
    
    # 포크된 저장소인지 확인 (origin과 upstream이 모두 있는 경우)
    if [[ " ${remotes[*]} " =~ " origin " ]] && [[ " ${remotes[*]} " =~ " upstream " ]]; then
        echo -e "${BLUE}🍴 포크된 저장소를 감지했습니다.${NC}"
        echo "  - origin: $(git remote get-url origin)"
        echo "  - upstream: $(git remote get-url upstream)"
        
        # 기본적으로 upstream을 사용하되 사용자에게 선택권 제공
        echo -e "${YELLOW}💡 PR을 어느 저장소로 보내시겠습니까?${NC}"
        echo "  1. upstream (원본 저장소) - 권장"
        echo "  2. origin (포크된 저장소)"
        
        while true; do
            read -p "선택 (1-2, 엔터키=upstream): " -r remote_choice
            
            if [ -z "$remote_choice" ] || [ "$remote_choice" = "1" ]; then
                DEFAULT_REMOTE="upstream"
                break
            elif [ "$remote_choice" = "2" ]; then
                DEFAULT_REMOTE="origin"
                break
            else
                echo -e "${RED}❌ 잘못된 선택입니다. 1 또는 2를 입력해주세요.${NC}"
            fi
        done
    fi
    
    echo -e "${GREEN}✅ 사용할 원격 저장소: $DEFAULT_REMOTE${NC}"
    echo ""
    
    # 원격 저장소 연결 테스트
    if ! git ls-remote --heads "$DEFAULT_REMOTE" &>/dev/null; then
        echo -e "${RED}❌ '$DEFAULT_REMOTE' 원격 저장소에 접근할 수 없습니다.${NC}"
        echo "네트워크 연결이나 저장소 권한을 확인해주세요."
        exit 1
    fi
}

# 함수: OpenAI API 호출
call_openai() {
    local prompt="$1"

    # 시스템 메시지 정의
    local system_msg="당신은 GitHub PR 제목과 설명을 생성하는 전문가입니다. 커밋 메시지들과 코드 변경사항을 분석하여 상세하고 구체적인 PR 설명을 작성해주세요.

다음 형식으로 응답해주세요:

TITLE: [커밋들을 종합한 50자 이내의 명확한 제목]
DESCRIPTION:
## #️⃣연관된 이슈

resolves: #이슈번호

## 📝작업 내용

- 각 커밋에서 수행한 구체적인 작업들을 상세히 나열
- 추가된 기능의 목적과 작동 방식 설명
- 수정된 부분과 개선사항 설명
- 변경된 파일들의 역할과 영향도 분석
- 코드 품질 개선사항이나 리팩토링 내용

한국어로 작성하되, 개발자가 이해하기 쉽게 기술적인 내용도 포함해주세요."

    # JSON 요청 생성
    local json_data=$(jq -n \
        --arg model "gpt-4o-mini" \
        --arg system "$system_msg" \
        --arg user "$prompt" \
        --argjson max_tokens 800 \
        --argjson temperature 0.3 \
        '{
            model: $model,
            messages: [
                {role: "system", content: $system},
                {role: "user", content: $user}
            ],
            max_tokens: $max_tokens,
            temperature: $temperature
        }')

    # API 호출 (타임아웃 30초)
    local response
    response=$(curl -s --max-time 30 --connect-timeout 10 https://api.openai.com/v1/chat/completions \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $OPENAI_API_KEY" \
        -d "$json_data" 2>&1)
    
    local curl_exit_code=$?
    
    if [ $curl_exit_code -ne 0 ]; then
        echo -e "${RED}❌ API 호출 실패 (curl 종료 코드: $curl_exit_code)${NC}" >&2
        echo -e "${RED}네트워크 연결을 확인하거나 잠시 후 다시 시도해주세요.${NC}" >&2
        exit 1
    fi
    
    # JSON 파싱 및 오류 확인
    local content
    content=$(echo "$response" | jq -r '.choices[0].message.content // empty' 2>/dev/null)
    
    if [ -z "$content" ]; then
        local error_msg
        error_msg=$(echo "$response" | jq -r '.error.message // "알 수 없는 오류"' 2>/dev/null)
        echo -e "${RED}❌ API 오류: $error_msg${NC}" >&2
        echo -e "${YELLOW}응답 내용: $response${NC}" >&2
        exit 1
    fi
    
    echo "$content"
}

# 함수: Anthropic API 호출
call_anthropic() {
    local prompt="$1"
    curl -s --max-time 30 https://api.anthropic.com/v1/messages \
        -H "Content-Type: application/json" \
        -H "x-api-key: $ANTHROPIC_API_KEY" \
        -H "anthropic-version: 2023-06-01" \
        -d "{
            \"model\": \"claude-3-haiku-20240307\",
            \"max_tokens\": 800,
            \"system\": \"당신은 GitHub PR 제목과 설명을 생성하는 전문가입니다. 다음 형식으로 응답해주세요:\\n\\nTITLE: [50자 이내의 간단한 제목]\\nDESCRIPTION:\\n## #️⃣연관된 이슈\\n\\nresolves: #이슈번호\\n\\n## 📝작업 내용\\n\\n[이번 PR에서 작업한 내용을 간략히 설명]\\n\\n한국어로 작성해주세요.\",
            \"messages\": [
                {
                    \"role\": \"user\",
                    \"content\": \"$prompt\"
                }
            ]
        }" | jq -r '.content[0].text // .error.message // "API 호출 실패"'
}

# 명령줄 인수 처리
target_branch_arg=""
if [ "$1" = "--target" ] || [ "$1" = "-t" ]; then
    if [ -n "$2" ]; then
        target_branch_arg="$2"
        echo -e "${BLUE}📌 명령줄에서 지정된 대상 브랜치: $target_branch_arg${NC}"
        echo ""
        
        # 지정된 브랜치가 로컬과 원격에 존재하는지 확인
        if ! git show-ref --verify --quiet "refs/heads/$target_branch_arg"; then
            echo -e "${RED}❌ '$target_branch_arg' 로컬 브랜치가 존재하지 않습니다.${NC}"
            exit 1
        fi
        
        if ! git ls-remote --heads "$DEFAULT_REMOTE" "$target_branch_arg" | grep -q "$target_branch_arg"; then
            echo -e "${YELLOW}⚠️  '$target_branch_arg' 브랜치가 원격 저장소에 없습니다.${NC}"
            echo -e "${BLUE}💡 PR 생성을 위해 먼저 원격에 푸시가 필요합니다.${NC}"
            read -p "지금 푸시하시겠습니까? (y/N): " -r
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                echo -e "${BLUE}📤 '$target_branch_arg' 브랜치를 원격으로 푸시 중...${NC}"
                if git push -u "$DEFAULT_REMOTE" "$target_branch_arg"; then
                    echo -e "${GREEN}✅ 푸시 완료${NC}"
                else
                    echo -e "${RED}❌ 푸시 실패${NC}"
                    exit 1
                fi
            else
                echo -e "${YELLOW}❌ 원격 푸시 없이는 PR을 생성할 수 없습니다.${NC}"
                echo -e "${BLUE}💡 수동으로 푸시하려면: git push -u $DEFAULT_REMOTE $target_branch_arg${NC}"
                exit 1
            fi
        fi
    else
        echo -e "${RED}❌ --target 옵션에는 브랜치명이 필요합니다.${NC}"
        echo "사용법: aipr --target <브랜치명>"
        exit 1
    fi
elif [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
    echo "AI PR 생성 도구"
    echo ""
    echo "사용법:"
    echo "  aipr                    # 대화형 브랜치 선택"
    echo "  aipr --target <브랜치>   # 대상 브랜치 직접 지정"
    echo "  aipr -t <브랜치>        # 대상 브랜치 직접 지정 (단축형)"
    echo ""
    echo "예시:"
    echo "  aipr --target main"
    echo "  aipr -t develop"
    exit 0
fi

# API 키 및 GitHub CLI 확인 (도움말이 아닌 경우에만)
if [ "$1" != "--help" ] && [ "$1" != "-h" ]; then
    check_api_key
    check_gh_cli
    setup_remote_repository
fi

# 현재 브랜치 확인 (도움말이 아닌 경우에만)
if [ "$1" != "--help" ] && [ "$1" != "-h" ]; then
    current_branch=$(git branch --show-current)
    if [ "$current_branch" = "main" ] || [ "$current_branch" = "master" ]; then
        echo -e "${RED}❌ main/master 브랜치에서는 PR을 생성할 수 없습니다.${NC}"
        echo "새 브랜치를 생성하거나 기존 브랜치로 전환해주세요."
        exit 1
    fi
fi

# 현재 브랜치를 적절한 원격 저장소로 푸시
push_current_branch() {
    # 포크된 저장소인 경우 현재 브랜치는 origin에 푸시
    local push_remote="origin"
    
    # origin이 없으면 DEFAULT_REMOTE 사용
    if ! git remote | grep -q "^origin$"; then
        push_remote="$DEFAULT_REMOTE"
    fi
    
    echo -e "${BLUE}📤 현재 브랜치를 $push_remote로 푸시합니다...${NC}"
    
    # 푸시되지 않은 커밋이 있는지 확인
    if ! git diff --quiet HEAD "$push_remote"/"$current_branch" 2>/dev/null; then
        echo -e "${BLUE}📤 변경사항을 원격 저장소로 푸시합니다...${NC}"
        git push "$push_remote" "$current_branch" || {
            echo -e "${BLUE}📤 첫 번째 푸시입니다...${NC}"
            git push -u "$push_remote" "$current_branch"
        }
    fi
}

push_current_branch

# 대상 브랜치 선택
if [ -n "$target_branch_arg" ]; then
    # 명령줄에서 지정된 경우
    target_branch="$target_branch_arg"
else
    # 대화형 선택
    echo -e "${BLUE}🎯 PR을 보낼 대상 브랜치를 선택해주세요:${NC}"
    echo ""

    # 사용 가능한 브랜치 목록 표시 (로컬에 있는 모든 브랜치들)
    available_branches=()
    remote_status=()
    
    # 현재 브랜치를 제외한 모든 로컬 브랜치 가져오기
    local all_branches=($(git branch --format='%(refname:short)' | grep -v "^$current_branch$"))
    
    # 주요 브랜치들을 우선적으로 배치
    local priority_branches=("main" "master" "dev" "develop")
    
    # 우선순위 브랜치들을 먼저 추가
    for priority_branch in "${priority_branches[@]}"; do
        if [[ " ${all_branches[*]} " =~ " $priority_branch " ]]; then
            available_branches+=("$priority_branch")
            # 원격에 있는지 확인
            if git ls-remote --heads "$DEFAULT_REMOTE" "$priority_branch" | grep -q "$priority_branch"; then
                remote_status+=("✅")
            else
                remote_status+=("📤")
            fi
        fi
    done
    
    # 나머지 브랜치들을 알파벳 순으로 추가
    for branch in $(printf '%s\n' "${all_branches[@]}" | grep -v -E '^(main|master|dev|develop)$' | sort); do
        available_branches+=("$branch")
        # 원격에 있는지 확인
        if git ls-remote --heads "$DEFAULT_REMOTE" "$branch" | grep -q "$branch"; then
            remote_status+=("✅")
        else
            remote_status+=("📤")
        fi
    done
    
    # 브랜치가 하나도 없으면 기본 브랜치라도 표시
    if [ ${#available_branches[@]} -eq 0 ]; then
        if git show-ref --verify --quiet refs/heads/main; then
            available_branches+=("main")
            remote_status+=("✅")
        elif git show-ref --verify --quiet refs/heads/master; then
            available_branches+=("master")
            remote_status+=("✅")
        fi
    fi

    # 기본 브랜치 설정 (사용 가능한 브랜치 중에서 선택)
    default_branch=""
    if [ ${#available_branches[@]} -gt 0 ]; then
        # 우선순위: main > master > dev > develop > 첫 번째 브랜치
        for priority in "main" "master" "dev" "develop"; do
            if [[ " ${available_branches[*]} " =~ " $priority " ]]; then
                default_branch="$priority"
                break
            fi
        done
        
        # 우선순위 브랜치가 없으면 첫 번째 브랜치를 기본값으로
        if [ -z "$default_branch" ]; then
            default_branch="${available_branches[0]}"
        fi
    else
        # 사용 가능한 브랜치가 없으면 main/master 중 하나
        if git show-ref --verify --quiet refs/heads/main; then
            default_branch="main"
        else
            default_branch="master"
        fi
    fi

    # 브랜치 선택 메뉴 표시
    echo "사용 가능한 브랜치 (총 ${#available_branches[@]}개):"
    
    # 브랜치가 많을 때는 처음 20개만 표시하고 더보기 옵션 제공
    local display_limit=20
    local show_all=false
    
    if [ ${#available_branches[@]} -gt $display_limit ] && [ "$show_all" = false ]; then
        echo -e "${YELLOW}💡 브랜치가 많습니다. 처음 ${display_limit}개만 표시합니다.${NC}"
        echo ""
        
        for i in $(seq 0 $((display_limit-1))); do
            if [ $i -lt ${#available_branches[@]} ]; then
                branch="${available_branches[$i]}"
                status="${remote_status[$i]}"
                
                if [ "$branch" = "$default_branch" ]; then
                    echo -e "${GREEN}  $((i+1)). $branch (기본) $status${NC}"
                else
                    echo -e "${BLUE}  $((i+1)). $branch $status${NC}"
                fi
            fi
        done
        
        echo ""
        echo -e "${YELLOW}  a. 모든 브랜치 보기 (${#available_branches[@]}개)${NC}"
    else
        for i in "${!available_branches[@]}"; do
            branch="${available_branches[$i]}"
            status="${remote_status[$i]}"
            
            if [ "$branch" = "$default_branch" ]; then
                echo -e "${GREEN}  $((i+1)). $branch (기본) $status${NC}"
            else
                echo -e "${BLUE}  $((i+1)). $branch $status${NC}"
            fi
        done
    fi
    
    echo ""
    echo -e "${YELLOW}범례: ✅ 원격에 있음, 📤 원격 푸시 필요${NC}"

    # 직접 브랜치명 입력 옵션
    echo -e "${YELLOW}  0. 직접 입력${NC}"
    echo ""

    # 사용자 입력 받기
    while true; do
        if [ ${#available_branches[@]} -gt $display_limit ] && [ "$show_all" = false ]; then
            read -p "선택 (1-$display_limit, a=모두보기, 0=직접입력, 엔터키=기본값): " -r choice
        else
            read -p "선택 (1-${#available_branches[@]} 또는 0, 엔터키=기본값): " -r choice
        fi
        
        if [ -z "$choice" ]; then
            # 엔터키만 눌렀을 때 기본값 사용
            target_branch="$default_branch"
            break
        elif [ "$choice" = "a" ] && [ ${#available_branches[@]} -gt $display_limit ] && [ "$show_all" = false ]; then
            # 모든 브랜치 보기
            show_all=true
            echo ""
            echo "모든 브랜치 (총 ${#available_branches[@]}개):"
            for i in "${!available_branches[@]}"; do
                branch="${available_branches[$i]}"
                status="${remote_status[$i]}"
                
                if [ "$branch" = "$default_branch" ]; then
                    echo -e "${GREEN}  $((i+1)). $branch (기본) $status${NC}"
                else
                    echo -e "${BLUE}  $((i+1)). $branch $status${NC}"
                fi
            done
            echo ""
            echo -e "${YELLOW}범례: ✅ 원격에 있음, 📤 원격 푸시 필요${NC}"
            echo -e "${YELLOW}  0. 직접 입력${NC}"
            echo ""
            continue
        elif [[ "$choice" =~ ^[1-9][0-9]*$ ]] && [ "$choice" -le "${#available_branches[@]}" ]; then
            # 숫자 선택
            target_branch="${available_branches[$((choice-1))]}"
            break
        elif [ "$choice" = "0" ]; then
            # 직접 입력
            while true; do
                read -p "대상 브랜치명을 입력하세요: " -r target_branch
                if [ -n "$target_branch" ]; then
                    if ! git show-ref --verify --quiet "refs/heads/$target_branch"; then
                        echo -e "${RED}❌ '$target_branch' 로컬 브랜치가 존재하지 않습니다. 다시 입력해주세요.${NC}"
                        continue
                    fi
                    
                    if ! git ls-remote --heads "$DEFAULT_REMOTE" "$target_branch" | grep -q "$target_branch"; then
                        echo -e "${YELLOW}⚠️  '$target_branch' 브랜치가 원격 저장소에 없습니다.${NC}"
                        echo -e "${BLUE}💡 PR 생성을 위해 먼저 원격에 푸시가 필요합니다.${NC}"
                        read -p "지금 푸시하시겠습니까? (y/N): " -r
                        if [[ $REPLY =~ ^[Yy]$ ]]; then
                            echo -e "${BLUE}📤 '$target_branch' 브랜치를 원격으로 푸시 중...${NC}"
                            if git push -u "$DEFAULT_REMOTE" "$target_branch"; then
                                echo -e "${GREEN}✅ 푸시 완료${NC}"
                                break
                            else
                                echo -e "${RED}❌ 푸시 실패${NC}"
                                continue
                            fi
                        else
                            echo -e "${YELLOW}다른 브랜치를 선택하거나 수동으로 푸시하세요.${NC}"
                            continue
                        fi
                    fi
                    
                    break
                fi
            done
            break
        else
            echo -e "${RED}❌ 잘못된 선택입니다. 다시 선택해주세요.${NC}"
        fi
    done

    echo -e "${GREEN}✅ 대상 브랜치: $target_branch${NC}"
    echo ""
fi

echo -e "${BLUE}🤖 AI가 PR 제목과 설명을 생성하고 있습니다...${NC}"
echo ""

# 브랜치명에서 타입과 이슈 번호 추출 (예: feat/#123 -> feat, 123)
branch_type=""
issue_number=""

# 브랜치 타입 추출 (feat, fix, chore, docs 등)
if [[ "$current_branch" =~ ^([^/]+)/ ]]; then
    branch_type="${BASH_REMATCH[1]}"
fi

# 이슈 번호 추출
if [[ "$current_branch" =~ /#([0-9]+) ]]; then
    issue_number="${BASH_REMATCH[1]}"
elif [[ "$current_branch" =~ /([0-9]+)$ ]]; then
    issue_number="${BASH_REMATCH[1]}"
fi

# 변경사항 정보 수집 (대상 브랜치에 없는 새로운 커밋들만)
changed_files=$(git diff --name-only "$target_branch"..."$current_branch")
git_diff=$(git diff "$target_branch"..."$current_branch")
commit_messages=$(git log "$target_branch".."$current_branch" --oneline)
commit_details=$(git log "$target_branch".."$current_branch" --pretty=format:"- %s%n  %b" | grep -v "^$")

# 커밋이 없으면 종료
if [ -z "$commit_messages" ]; then
    echo -e "${RED}❌ $target_branch 브랜치와 비교했을 때 새로운 커밋이 없습니다.${NC}"
    echo "변경사항을 커밋하거나 올바른 브랜치에서 실행해주세요."
    exit 1
fi

# 프롬프트 생성
prompt="다음 정보를 바탕으로 GitHub Pull Request의 제목과 설명을 생성해주세요:

브랜치: $current_branch → $target_branch
브랜치 타입: ${branch_type:-"없음"}
이슈 번호: ${issue_number:-"없음"}

변경된 파일 목록:
$changed_files

새로운 커밋들 ($target_branch 브랜치에 없는 것들):
$commit_messages

상세 커밋 내용:
$commit_details

코드 변경사항 (일부):
$(echo "$git_diff" | head -200)

요구사항:
1. 제목은 50자 이내로 간결하게 (커밋 메시지들을 종합해서)
   - 브랜치 타입이 있으면 제목 앞에 타입을 추가
   - 예: feat: 파일 업로드 기능 추가, fix: 로그인 오류 수정
2. 설명 형식:
   ## #️⃣연관된 이슈
   resolves: #이슈번호

   ## 📝작업 내용
   - 각 커밋에서 작업한 구체적인 내용들을 정리
   - 추가된 기능, 수정된 부분, 개선사항 등을 상세히 설명
   - 변경된 파일들의 역할과 목적 설명
   - 코드 변경사항이 프로젝트에 미치는 영향
3. NestJS 프로젝트임을 고려 (컨트롤러, 서비스, 모듈 등)
4. 한국어로 작성
5. 커밋 메시지들을 종합하여 전체적인 맥락을 파악해서 작성

응답 형식:
TITLE: [제목]
DESCRIPTION:
[설명 내용]"

# AI API 호출
if [ -n "$OPENAI_API_KEY" ]; then
    echo -e "${BLUE}📡 OpenAI API 호출 중... (30초 타임아웃)${NC}"
    ai_response=$(call_openai "$prompt")
elif [ -n "$ANTHROPIC_API_KEY" ]; then
    echo -e "${BLUE}📡 Anthropic API 호출 중... (30초 타임아웃)${NC}"
    ai_response=$(call_anthropic "$prompt")
else
    echo -e "${RED}❌ API 키가 설정되지 않았습니다.${NC}"
    exit 1
fi

echo -e "${GREEN}✅ AI 응답 받음 (${#ai_response}자)${NC}"

# 제목과 설명 분리
pr_title=$(echo "$ai_response" | grep "^TITLE:" | sed 's/^TITLE: //')
pr_description=$(echo "$ai_response" | sed '/^TITLE:/d' | sed '/^DESCRIPTION:/d' | sed '/^$/d')

if [ -z "$pr_title" ]; then
    pr_title="$current_branch 브랜치 변경사항"
fi

# 브랜치 타입이 있고 제목에 아직 포함되지 않았으면 추가
if [ -n "$branch_type" ] && [[ ! "$pr_title" =~ ^[a-z]+: ]]; then
    pr_title="${branch_type}: ${pr_title}"
fi

# 이슈 번호가 있으면 자동으로 치환
if [ -n "$issue_number" ]; then
    pr_description=$(echo "$pr_description" | sed "s/#이슈번호/#$issue_number/g")
fi

echo -e "${GREEN}✨ AI가 생성한 PR 정보:${NC}"
echo "================================"
echo -e "${YELLOW}제목:${NC} $pr_title"
echo ""
echo -e "${YELLOW}설명:${NC}"
echo "$pr_description"
echo "================================"
echo ""

# 사용자 확인
read -p "이 내용으로 PR을 생성하시겠습니까? (y/N): " -r

if [[ $REPLY =~ ^[Yy]$ ]]; then
    # PR 생성
    echo -e "${BLUE}📝 PR을 생성하고 있습니다...${NC}"

    # 임시 파일에 설명 저장
    temp_file=$(mktemp)
    echo "$pr_description" > "$temp_file"

    # GitHub CLI로 PR 생성
    # 포크된 저장소에서 upstream으로 PR을 보내는 경우 처리
    if [ "$DEFAULT_REMOTE" = "upstream" ]; then
        # 현재 브랜치가 origin에 있고 upstream으로 PR을 보내는 경우
        origin_user=$(git remote get-url origin | sed -n 's/.*github.com[:/]\([^/]*\)\/.*/\1/p')
        pr_url=$(gh pr create --title "$pr_title" --body-file "$temp_file" --base "$target_branch" --head "$origin_user:$current_branch" --repo $(git remote get-url upstream | sed -n 's/.*github.com[:/]\([^/]*\/[^/]*\)\.git.*/\1/p'))
    else
        # 일반적인 경우 (origin에서 origin으로, 또는 단일 원격 저장소)
        pr_url=$(gh pr create --title "$pr_title" --body-file "$temp_file" --base "$target_branch" --head "$current_branch")
    fi

    # 임시 파일 삭제
    rm "$temp_file"

    echo -e "${GREEN}✅ PR이 성공적으로 생성되었습니다!${NC}"
    echo -e "${BLUE}🔗 PR URL: $pr_url${NC}"

    # 브라우저에서 열기 (선택사항)
    read -p "브라우저에서 PR을 여시겠습니까? (y/N): " -r
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        gh pr view --web
    fi

else
    echo -e "${YELLOW}❌ PR 생성이 취소되었습니다.${NC}"
    echo -e "${BLUE}💡 수동으로 PR을 생성하려면:${NC}"
    echo "gh pr create --title \"$pr_title\" --body \"$pr_description\""
fi
